<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Trees and frog effect</title>
		<script src="http://threejs.org/build/three.js"></script>
		<script>
		window.onload = function() { 
		
			//Define the WebGL renderer
			var renderer = new THREE.WebGLRenderer({antialias: true }); // set antialias as true
			renderer.setSize(800, 600); // Scene size (Width, Height)
			renderer.setClearColor( 0x000066 );
			
			document.body.appendChild(renderer.domElement);
			
			// define the scene
			var scene = new THREE.Scene();
			/*axis to help, learned from video
			var axis = new THREE.AxisHelper(10);
			scene.add(axis);*/
			//add fog
			scene.fog = new THREE.FogExp2( 0x000000, 0.005 );
			
			//define the camera
			var camera = new THREE.PerspectiveCamera(
					45,             // Field of view
					800 / 600,      // Aspect ratio
					0.1,            // Near plane
					600           // Far plane
			);
			camera.position.x= 0;  //default value anyway
			camera.position.y= 0;  //default value anyway
			camera.position.z = 150;  //We move the camera backwards to see all the scene
			camera.lookAt(scene.position);
			// object
			//snow effect
		    var particles = new THREE.Geometry;
			for (var p = 0; p<1000; p++) {
				var particle = new THREE.Vector3(Math.random() * 400 - 250, Math.random() * 400 - 250, Math.random() * 400 - 250);
				particles.vertices.push(particle);
			}
			var particleMaterial = new THREE.ParticleBasicMaterial({ color: 0xffffff, size: 0.5 });
			var particleSystem = new THREE.ParticleSystem(particles, particleMaterial);
			scene.add(particleSystem);
			// trees
			for (var j = 0; j < 100; j++) {
			
              var xx = Math.random() * 150 - 75; // value from -80 to 80
              var yy = Math.random() * 70 - 55; // value from -40 to 10
              var zz = Math.random() * 10; // value from 0 to 20

              //Generate random scaling
              var scaleX = Math.random() + 0.2;

              var rotateValue = Math.random() * 2 - 1;

              for(var i = 0; i < 5; i++){

                var geometry = new THREE.Geometry();
                geometry.vertices.push(new THREE.Vector3(0,0,0));
                geometry.vertices.push(new THREE.Vector3(4.5,0,0));
                geometry.vertices.push(new THREE.Vector3(2.25,3.75,0));
                geometry.faces.push(new THREE.Face3(0, 1, 2));
                geometry.computeFaceNormals();
                var triangles = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: 0x1a3300}));

                //Transform top part of tree. Scale x (y distorts placement of segments) and scale. 
                triangles.translateX(xx);
                triangles.translateY(yy+(i*1.1));
                triangles.translateZ(zz);
                triangles.rotateY(rotateValue);
                triangles.scale.x = scaleX;
                scene.add(triangles);  
                //triangles.scale.set(scaleRatio);
              }
            }
			
			function drawTree(times, xx, yy, zz) {
                
                //Generate random branch thickness
                var randomWidth = Math.random() * 2;
                //Basic tree material, brown
                var material = new THREE.LineBasicMaterial({color: 0x1a0d00, linewidth: randomWidth});

                //Generate new vertical segment random height, all branches created will have this value as their y coordinate (all will begin with (xx, yOrigin, zz))
                var yOrigin = yy + Math.floor(Math.random() * 2 + 1);

                //VERTICAL SEGMENT ADDITION
                var geometry = new THREE.Geometry();
                //Starting point of vector will be endpoint passed in function, end point will be yOrigin random units upwards.
                geometry.vertices.push(new THREE.Vector3( xx, yy, zz ), new THREE.Vector3( xx, yOrigin, zz));
                var line = new THREE.Line( geometry, material );
                //Add to scene
                scene.add( line );
                //Call function recursively to draw branches connecting to new vertical branch.
                if (times > 0) {
                    drawTree(times-1, xx, yOrigin, zz);
                }

                //RIGHT SEGMENT ADDITION
                //Generate random width and height of new branch
                var randomX = xx + Math.floor(Math.random() * 2 + 1);
                var randomY = yOrigin + Math.floor(Math.random() * 2 + 1);
                var geometry = new THREE.Geometry();
                //Start point is top of first vertical (xx, yOrigin, zz) and endpoint is new random x and y variables. 
                geometry.vertices.push(new THREE.Vector3( xx, yOrigin, zz ), new THREE.Vector3( randomX, randomY, zz ));
                var line2 = new THREE.Line( geometry, material );
                scene.add( line2 );
                //Recursively add branches to this new branch
                 if (times > 0) {
                    drawTree(times-1, randomX, randomY, zz);
                }

                //SECOND VERTICAL SEGMENT ADDITION
                var randomY = yOrigin + Math.floor(Math.random() * 2 + 1); 
                var geometry = new THREE.Geometry();
                //Vector begins at origin of branch and extends random y coordinate upwards.
                geometry.vertices.push(new THREE.Vector3( xx, yOrigin, zz ), new THREE.Vector3( xx, randomY, zz ));
                var line3 = new THREE.Line( geometry, material );
                scene.add(line3);
             
                //LEFT SEGMENT ADDITION
                //Generate random x coordinate (moving to left) and random y coordinate.
                var randomX = xx - Math.floor(Math.random() * 2 + 1);
                var randomY = yOrigin + Math.floor(Math.random() * 2 + 1);
                var geometry = new THREE.Geometry();
                geometry.vertices.push(new THREE.Vector3( xx, yOrigin, zz ), new THREE.Vector3(randomX, randomY, zz ));
                var line4 = new THREE.Line( geometry, material );
                scene.add( line4 );
                //Recursively add branches to new left segment
                 if (times > 0) {
                    drawTree(times-1, randomX, randomY, zz);
                }

            }

            //Generate 50 branching trees
            for (var i = 0; i < 75; i++) {

                //Generate random tree height
                var levels = Math.floor(Math.random() * 4);
                //Generate random tree positioning
                var xx = Math.random() * 150 - 75; // x value from 25 to 50
                var yy = Math.random() * 70 - 55; //y value from 0 to -20
                var zz = Math.random() * 10; //z value from 0 to 50
                //Draw tree
                drawTree(levels, xx, yy, zz);
            }
			
			
			//plane object
		    var planeGeometry = new THREE.PlaneGeometry(200, 200, 200);
            //It defines colour green:
            var material = new THREE.MeshBasicMaterial( {color: 0xffffff} );
            var plane = new THREE.Mesh(planeGeometry,material);
			plane.translateY(-80);
            scene.add(plane);
			/*
			//skybox
			THREE.ImageUtils.crossOrigin = '';
			var test = 'http://i.imgur.com/NSlogkx.jpg';
			var urls = [test,test,test,test,test,test];
			var cubemap = THREE.ImageUtils.loadTextureCube(urls); // load texture
			cubemap.format = THREE.RGBFormat;
			var shader = THREE.ShaderLib['cube']; // init cube shader from built-in lib
			shader.uniforms['tCube'].value = cubemap; // apply textures to shader
			// create shader material
			var skyBoxMaterial = new THREE.ShaderMaterial( {
			fragmentShader: shader.fragmentShader,
			vertexShader: shader.vertexShader,
			uniforms: shader.uniforms,
			depthWrite: false,
			side: THREE.BackSide
			});
			// create skybox mesh
			var skybox = new THREE.Mesh(new THREE.CubeGeometry(1000, 1000, 1000),skyBoxMaterial);
			scene.add(skybox);
			*/
			//light source
			
			var spotLight = new THREE.SpotLight(0xFFFFFF);
			//spotLight.castShadow = true;
			spotLight.position.set (15,30,50);
			scene.add(spotLight);
			
			// Render the scene:
			var render = function () {
				requestAnimationFrame(render); //this will update scene frames.
				particleSystem.rotation.y += 0.01;
			    particleSystem.rotation.x += 0.01;
			    renderer.render(scene, camera); //renders the whole scene, updating it recursively.
			};
			render();
		};
		</script>
	</head>
	<body></body>
</html>